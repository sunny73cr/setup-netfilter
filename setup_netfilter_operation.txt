
setup-netfilter operation

 1. query user regarding the envrionment
  identify an alias (or use the hostname) of this PC.
  identify an alias, mac, ip tuple for each network peer.
  identify the default gateway by its alias.

 2. (programatically) query each interface configuration:
  classify it - is it virtual or physical?
# FUTURE - set per-frame capability - what is the MTU?
# FUTURE - set multi-frame capability - what is the maximum bandwidth?
# FUTURE - set environmental restrictions - what times can the interface use a set bandwidth, if any?
  identify the interface (MAC) - what is the mac address?
  identify the interface (IP4 and 6) - what are the IP address/es?
  identify the topology - what are the VLAN tags, if any?
# FUTURE - route the interface - how to reach other computers?

  then, ask the user:
  alias it - can the interface be described by a friendly name?
  zone it - is the interface internal, private, intranet, or internet facing?

 interface configuration data is stored in an '.snicfg' file:
# SETUP-NETFILTER wan0.10 CONFIG - DO NOT MODIFY THIS FILE - IT IS GENERATED AND SHOULD REMAIN THAT WAY

 3. query user about the traffic signatures they wish to allow.

 begin by asking the direction (inbound or outbound).
 then ask 'which interface' (show an numbered list with the previously configured aliases and some information).
 then, if inbound, ask the source MAC; or if outbound, ask the destination MAC (if any restrictions).
 then, if they wish to configure rule/s for a well-known protocol (DHCP,HTTP,DNS), or something more custom (config ends at l4proto)

 it is difficult to identify a rule by its entire definition, as the project supports configuration of many more parameters than what is usually available.
 instead, rule definitions should be identified by a short signature.
 a short-hand format further defines specifications of the rule.
 for example; when picking a rule to act upon, the user should see if, dir, vlan, mac, ip, port, and the name (and potentially sub-type) of the l7proto, if any

# a document-store or a 'no-sql' database may fit this project best due to undefined user requirements, of which are difficult or risky to define 'publicly'.
# I would prefer SQL for ease of use (see 'MongoDB projections' for an idea of API complexity).
# users need not have skill with databases in order to simply use what should be an easy-to-use program.
# regardless, any kind of 'database'-backed system is intended for the closed-source C++ variant of this project.
# it may be that I end up heavily limiting what can be supported in the dash variant of setup-netfilter for my own sanity.
# in this case;

 the signature of a rule definition is as follows:

 interface,
 direction, 
 [vlan tag/s (service and customer tags)],
 [mac address source & destination],
 [(network service) user id],
 [ipv4/6 address source & destination],
 { ['first' protocol (TCP/UDP/ICMP)], [source & destination port] },
 { ['second' protocol (OpenVPN,DHCP,HTTP/DNS/SSH/NTP/etc...)], ['second' protocol type (NTP Stratum 1, NTP Stratum 2+) ] }  

 there should be an index file containing a newline-delimited list of tilde separated randomly generated ID and 'short-hand definition' key-value pairs for each rule.
 a cache of the output generated by analysing the 'short signature' is located in another file, named as the generated ID.
 this allows for a simple CLI listing rule ID's and their short signatures, with the option to view the real rule, delete the rule, edit the rule, etc.
 the randomly generated ID is an 8-character hexadecimal string - fits in a 32-bit int

 index file structure and example:

 the format is described as:
  rule id
  verdict
  interface[.vlan]
  source mac address
  destination mac address
  ethertype name
  ~~ following varies based on ethertype name  ~~
  source ip address
  destination ip address
  layer 4 protocol name
  ~~ following varies based on layer 4 protocol name ~~
  source port
  destination port
  layer 7 protocol name
  ~~ following varies based on layer 7 protocol name ~~
  ntp packet type
  ntp packet 'direction' (request/response)
  ntp 'net type' (root delay/dispersion config)
  ntpClockIsSynchronised (enforce a range for reference timestamp to avoid intentional clock skew)

 the actual format is:
 
  note that 'grave (`)' indicates a null value - typically this indicates that no restriction is made upon this value
 
  # SETUP-NETFILTER INDEX - DO NOT MODIFY THIS FILE - IT IS GENERATED AND SHOULD REMAIN THAT WAY
   a3b5c38f~pass out wan0.10 997 02:00:00:00:00:01 ` ip4 100.64.54.253 ` udp 123 123 ntp stratum2plus request ntpNetType[bad-wan] ntpClockIsSynchronised[yes]



 then, the file 'a3b5c38f.snrule' contains the combined output of:

  setup-netfilter/RULE_HELPERS/LAYER_1/try_match_interface.sh
  setup-netfilter/RULE_HELPERS/ETHERNET/try_match_ethernet_header.sh
  setup-netfilter/RULE_HELPERS/IPV4/try_match_ipv4_header.sh
  setup-netfilter/RULE_HELPERS/UDP/try_match_udp_header.sh
  setup-netfilter/RULE_HELPERS/NTP/try_match_ntp_stratum_2_or_greater.sh

 'a3b5c38f.snrule' is a complete match, log, verdict rule description suitable for directly 'copying' into an nft chain definition.
 the header is similar:
# SETUP-NETFILER RULE a3b5c38f - DO NOT MODIFY THIS FILE - IT IS GENERATED AND SHOULD REMAIN THAT WAY

 maintaining the index of short-form rules should boost user productivity, and performance of setup-netfiler during regeneration of the ruleset after an edit.
 if every rule were re-generated with a minor change, the delay could be significant.

 rule definition

 output traffic

  need DHCP? - if the answer to 'identify IP of an interface' included 'dynamic':
   what is the name or ID of the DHCP service/s?
   what servers can we send to/ receive from?
   what kinds of DHCP are allowed?
#   match transaction ID for DHC PDISCOVER/OFFER - this is impossible without a C++ migration

 need ARP? - (as above)
   what is the name or ID of the ARP service/s?
   which peers can we send to/ receive from?
   which kinds of ARP are allowed?

  need NTP?
   what is the name or ID of the NTP service/s?
   what servers can we send to/ receive from?
   what kinds of NTP are allowed?
    if NTP client, likely only Stratum 2 requests out and responses in.
    if NTP server, likely Stratum 1+ requests out and responses in, and Kiss Of Death/Control Channel

  need DNS?
   what is the name or ID of the DNS service/s?
   what servers can we send to/ receive from?
   what kinds of DNS are allowed?
    needs some kind of database for remembering names.
#   dynamic and automatic rule edits based on DNS data - TTL indicates permit lifetime - this is impossible without a C++ migration

  need ICMP?
   what is the name or ID of the DNS service/s?
   what computers can we send to/ receive from?
   what kinds of ICMP are allowed?

  need Web Browsing?
   what is the name or ID of the Web Browsing service/s?
   what computers can we send to/ receive from?
#  what kinds of HTTP/HTTPS/WS/WSS are allowed? - this is impossible without a C++ migration
#  how long can the webserver transmit/receive to a machine? - this is impossible without a C++ migration
#   eg. once, for a period, for a bandwidth limit, until window close (requires integration with a browser plugin), until download complete - these are impossible without a C++ migration

  need APT?
   what is the name or ID of the APT service/s?
   what computers can we send to/ receive from?
   possible ports are http 80, https 443, ftp 21, ssh 22
#  what kinds of APT operations are allowed? - this is impossible without a C++ migration

  need SSH?
   what is the name or ID of the SSH service/s?
   what computers can we send to/ receive from?

  need Steam? (you may need to chill out after all this thinking...)
   what is the name or ID of the steam service/s?
   what computers can we send to/ receive from?

  need PostgreSQL?
   what is the name or ID of the Postgres service/s?
   what computers can we send to/ receive from?

...etc (more signatures to be defined)

  need custom IPV4?
   what is the name or ID of the IPV4 service/s?
   what computers can we send to/ receive from
   any limitations on the IPV4 packets?

  need custom TCP?
   what is the name or ID of the TCP service/s?
   what computers can we send to/ receive from
   any limitations on the TCP packets?

  need custom UDP?
   what is the name or ID of the UDP service/s?
   what computers can we send to/ receive from
   any limitations on the UDP packets?

  for each TCP outbound, there should be a rule covering a potential TCP FIN or RST outbound, where a conntrack state is 'established'
# it would be beneficial to write some conntrack 'helpers' in C; contributing to the conntrack project.
# it benefits both this project and the community as a whole. HTTP is a great example.



 input traffic

  need SSH?
   what is the name or ID of the SSH service/s?
   what computers can we send to/ receive from?

  for each TCP outbound, there should be a rule covering a potential TCP FIN or RST inbound, where a conntrack state is 'established'
  for each UDP outbound, there should be a rule covering a potential ICMP Destination Host, Network or Port Unreachable inbound, where a conntrack state is established.
# it would be beneficial to write some conntrack 'helpers' in C; contributing to the conntrack project.
# it benefits both this project and the community as a whole. HTTP is a great example.



 forwarded traffic

  for a 'router' environment, forwarded traffic rules can be as simple as allowing traffic to/from a configured subnet.
  though, this project aims to 'tighten the belt' by as many notches and where possible, so, a strict ruleset may as well be used for this POV too.

  it would be nice to setup a client/server approach for retrieval of client needs.
  the application of an allow/deny list after digital retrieval should not be completely automated.
  though, an admin panel allowing a priveleged user to accept or deny specific signatures is a nice idea.
  additionally, in-person confirmation of a required signature may be mandated by company policy.
  digital management of network requirements could aid in documentation of said network.
# this feature will be included in the closed-source variant of setup-netfilter.



 4. build base chains, then if needed, build 'stub' chains to filter traffic by interface, direction and vlan, then ip4 or 6, then l4proto; the l4proto chain then includes each l7proto rule.

 5. populate these chains with the relevant rules.

 6. apply the ruleset

 ...

 7. possibly - an interactive list whereby the user can identify, display, edit, or delete a rule from the set.
